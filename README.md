# USG 프로젝트 2차 [ 중고 책거래 플랫폼 ]
****
## 프로젝트 소개

중고 거래라는 앱 기반의 지역 커뮤니티를 통해서 자신의 동네에서 개인 간의 거래로 각 취향에 맞는 물품을 거래하고 필요한 목적에 따라서 원하는 것이 구매가 가능한 서비스

어플리케이션을 통한 간단한 접근성으로 누구든지 구매자와 판매자가 될 수 있는 신뢰성이 있는 중고거래 사이트를 제작하였다.

****
## 기술 스택
![image](https://github.com/Namsoo315/USG_PJ_2/assets/113406187/bbceb8bc-21fd-4a53-93b4-a419ddb2d5d6)
서버는 각자 백엔드로 채팅, 멤버, 책, 게이트웨이가 있으며프론트에는 안드로이드 스튜디오로 통해 클라이언트 서버를 구성하였습니다. 그리고 GCP를 MSA 방식으로 백엔드 서버를 각각 공유하였으며 클라이언트 서버를 통해 API요청을 보내서 실제 사용을 할 수 있게 만들었습니다.

그리고 기존 아키텍처를 사용하지 않고 새로운 접근 방식인 헥사고날 아키텍처를 사용하였는데 
먼저 헥사고날 아키텍처에 대해서 설명하겠다.

### 헥사고날 아키텍처
![image](https://github.com/Namsoo315/USG_PJ_2/assets/113406187/25388b6d-53cb-4337-8f71-c5ab9b72dcb0)

헥사고날 아키텍처 란 비즈니스 로직을 외부 세계로부터 격리시켜 유연하고 테스트하기 쉬운 구조를 설계하는 것이다.
이를 위해 핵심 비즈니스 로직은 중앙의 도메인 영역에 위치하며, 입력과 출력을 처리하는 포트와 어댑터를 통해 외부와 소통을 하게 된다.

장점으로는 유즈케이스로 실제 사용 하는 기능들을 정의 할 수있으며 결합도도 낮추어 유지보수성을 충분히 좋게 만드는 역할을 합니
다. 이렇게 헥사고날 아키텍처는 외부 시스템과의 결합도를낮춰 유지보수, 테스트의 용이성을 향상시키는데 기여를 하게됩니다. 
이는 시스템을 더욱 유연하고 확장 가능하게 만들어주는 역할을 합니다.

****

## 프로젝트 세부 시스템 구조

### 프론트 서버
![image](https://github.com/Namsoo315/USG_PJ_2/assets/113406187/793602e5-35f9-449d-96e4-115fafbe77c8)
UI 개발을 간소화하기 위해 JetPack Compose에서 설계된 최신 툴킷입니다. XML 기반의 작업이 불편하여 훨씬 최신기술이고 편
한 컴포즈를 사용하여 프론트 코드에 편의성을 부가하였습니다.

### 백엔드 서버 (Redis, Kafka)
![image](https://github.com/Namsoo315/USG_PJ_2/assets/113406187/35cf3d2c-3f3f-41ce-9593-8db5a5b663ab)

각 서버는 필요한 정보를 독립적인 데이터베이스에 저장합니다. 필요한 정보는 Kafka를 통해 전달하고, Redis에 저장된 데이터를 조인하는 방식을 사용합니다. Redis를 사용한 이유는 메모리 기반 저장소로서 대기 시간이 낮고 처리량이 높아 성능상 이점이 있기 때문입니다. 회원가입 시 멤버 서버는 Kafka를 통해 멤버 데이터를 책 및 채팅 서버에 전송하며, 각 서버는 비동기적으로 메시지를 읽어 Redis에 저장합니다. 필요한 데이터 조회는 CQRS 패턴을 도입하여 처리합니다.

### 백엔드 서버 (CQRS)
![image](https://github.com/Namsoo315/USG_PJ_2/assets/113406187/f6436603-0c17-42e0-ab72-28c5960eecf3)

MSA 환경에서 각 서버는 독립된 데이터베이스를 사용합니다. CQRS 패턴을 도입해 명령(Command)과 조회(Query)를 분리합니다. JWT 토큰에 사용자의 이메일을 클레임으로 등록하고, 책을 등록할 때 이 이메일을 데이터와 함께 저장합니다. 책 서버는 Kafka를 통해 비동기 방식으로 사용자 이메일과 닉네임 ID를 Redis에 저장합니다. 닉네임을 반환할 때는 이메일을 키로 사용해 Redis에서 해당 정보를 조회합니다. 이렇게 CQRS와 MSA를 활용해 시스템을 효율적으로 운영하며 데이터 일관성과 확장성을 유지합니다.

### 백엔드 서버 (STOMP)
![image](https://github.com/Namsoo315/USG_PJ_2/assets/113406187/a555b697-ac89-4338-af67-d15e4bac1f96)

STOMP(Simple Text Oriented Messaging Protocol)는 웹소켓 위에서 동작하는 문자 기반 메시징 프로토콜로, 클라이언트와 서버 간의 메시지 유형, 형식, 내용을 정의하는 메커니즘을 제공합니다. 1:1 채팅 구현을 위해 STOMP를 사용했는데, 이는 메시지 전송을 효율적으로 하기 위해 설계된 프로토콜입니다. 기존 웹소켓은 채팅방과 세션을 관리하는 추가 코드가 필요하지만, STOMP는 이를 단순화합니다. STOMP는 메시지 브로커를 통해 publisher로부터 받은 메시지를 subscriber에게 전달합니다. 클라이언트는 SEND와 SUBSCRIBE 명령을 사용해 메시지의 내용과 수신 대상을 설명하는 목적지 헤더와 함께 메시지를 송신하거나 구독할 수 있습니다. 이를 통해 클라이언트 간의 메시지 전송을 간편하게 처리할 수 있습니다.

### 백엔드 서버 CI, CD (GCP)
![image](https://github.com/Namsoo315/USG_PJ_2/assets/113406187/babced85-40d1-4cf4-9d52-88a14822b899)

저희는 GCP를 활용하여 MSA 방식으로 구성된 서버들을 각 인스턴스에 배포했습니다. 이를 위해 게이트웨이를 통해 요청을 라우팅하고, 각 서버는 도커 이미지를 컨테이너화하여 구동했습니다. CI/CD 파이프라인을 구축하여 코드 변경 사항이 자동으로 빌드, 테스트, 배포되도록 설정했습니다.

![image](https://github.com/Namsoo315/USG_PJ_2/assets/113406187/8de35cf6-6149-4f39-b55a-68133ec7fe58)

GCP의 GCS(Google Cloud Storage)를 사용하여 이미지 데이터를 버킷에 저장했습니다. API 요청을 통해 이미지 업로드, 수정, 삭제가 가능하도록 구현했으며, 이미지는 URL을 통해 접근할 수 있게 했습니다. 책 데이터에는 이미지 URL을 저장하여 클라이언트 측에서 해당 URL을 통해 이미지를 로드하도록 했습니다. 이를 통해 배포와 이미지 관리를 자동화하고 효율적으로 처리할 수 있었습니다.

****
##  프로젝트 결과

![image](https://github.com/Namsoo315/USG_PJ_2/assets/113406187/b975f6e7-2b12-44b5-ad0d-1f8e1751044a)
서버는 각자 백엔드로 채팅, 멤버, 책, 게이트웨이가 있으며 프론트에는 안드로이드 스튜디오로 통해 클라이언트 서버를
구성하였습니다. 그리고 GCP를 MSA 방식으로 백엔드 서버를 각각 공유하였으며 클라이언트 서버를 통해 API요청을 보내서 실제 사용을 할 수 있게 만들었습니다.

시스템의 흐름과 프론트와 결합도도 안전하게 성공하였으며 테스트 코드도 같이 작성하였기 떄문에 좀 더 안정성을 높여 완성도를 더욱 높였습니다.
